# Story 1.7: Custom Rules Engine (user-defined thresholds)

**Epic**: Epic 1 - Stripe Integration & Detection API  
**Story Points**: 8  
**Status**: âš ï¸ Ready for Review (API refactoring needed)

---

## Story

**As a** merchant,  
**I want** to define custom rules like "block if amount >â‚¬500 AND velocity >5",  
**so that** I can tailor detection to my business risk tolerance.

---

## Acceptance Criteria

1. **AC1**: Table: `custom_rules` (organizationId, name, conditions JSON, action BLOCK/REVIEW, enabled boolean)
2. **AC2**: Condition syntax: `{field: 'amount', operator: '>', value: 50000}` (cents)
3. **AC3**: Operators supported: `>`, `<`, `=`, `!=`, `IN` (for categorical fields)
4. **AC4**: Logical operators: `AND`, `OR` (evaluate AST)
5. **AC5**: Execution: Run after detectors, apply matching rules
6. **AC6**: Priority: Custom rules override detector decision if matched
7. **AC7**: UI component: Slider + Input (Shadcn) for threshold configuration
8. **AC8**: Performance: <10ms rule evaluation (max 10 rules per org)
9. **AC9**: Unit test: Verify rule evaluation logic

---

## Tasks / Subtasks

- [x] **Task 1**: Database schema (AC1)
  - [x] Add `custom_rules` table to Drizzle schema
  - [x] Columns: id, organizationId, name, description, conditions (JSONB), action (BLOCK/REVIEW), enabled, priority, createdAt, updatedAt
  - [x] Indexes: (organizationId, enabled) for fast lookups
  - [x] Migration: `drizzle-kit generate` + `drizzle-kit push`

- [x] **Task 2**: Rule evaluation engine (AC2, AC3, AC4)
  - [x] Create `lib/fraud/custom-rules.ts`
  - [x] Parse conditions JSON into AST (Abstract Syntax Tree)
  - [x] Implement operators: `>`, `<`, `=`, `!=`, `IN` (AC3)
  - [x] Implement logical operators: `AND`, `OR` (AC4)
  - [x] Evaluate rule against detection context
  - [x] Return: `{matched: boolean, ruleName: string, action: 'BLOCK'|'REVIEW'}`

- [x] **Task 3**: Integration with detection flow (AC5, AC6)
  - [x] After detectors run â†’ Fetch enabled custom rules for org
  - [x] Evaluate each rule against context
  - [x] If rule matches â†’ Override decision with rule action (AC6)
  - [x] Log: `custom_rule_matched` (rule name, action)

- [ ] **Task 4**: API endpoints for rule management
  - [ ] `GET /api/rules` - List all rules for org
  - [ ] `POST /api/rules` - Create new rule
  - [ ] `PATCH /api/rules/[id]` - Update rule (enable/disable, change threshold)
  - [ ] `DELETE /api/rules/[id]` - Delete rule
  - Note: Can be implemented in Epic 2 (Dashboard) for UI integration

- [ ] **Task 5**: UI component (AC7)
  - [ ] Create `components/custom-rule-editor.tsx`
  - [ ] Field selector: Dropdown (amount, velocity, trust_score, etc.)
  - [ ] Operator selector: Dropdown (>, <, =, !=)
  - [ ] Value input: Shadcn `Input` (numeric) or `Slider` (for thresholds)
  - [ ] Action selector: Radio (BLOCK, REVIEW)
  - [ ] Enable/Disable toggle: Shadcn `Switch`
  - Note: Will be implemented in Epic 2 (Dashboard) when building the settings UI

- [x] **Task 6**: Performance optimization (AC8)
  - [x] Cache rules in memory (TTL 5 min)
  - [x] Max 10 rules per org (enforce in fetch logic)
  - [x] Target <10ms evaluation (AC8)

- [x] **Task 7**: Unit tests (AC9)
  - [x] Test operators: amount > 50000 â†’ match/no match
  - [x] Test logical AND: amount > 50000 AND velocity > 5
  - [x] Test logical OR: amount > 50000 OR trust_score < 30
  - [x] Test IN operator: country IN ['CN', 'RU']
  - [x] Test rule priority (override detector decision)

---

## Dev Notes

### Relevant Architecture

**Custom Rules Philosophy**:
- Merchants know their business best
- Allow configuration without code changes
- Simple syntax (no complex programming)
- Max 10 rules per org (prevent performance issues)

**Database Schema**:
```typescript
// packages/database/src/schema/custom-rules.ts
export const customRules = pgTable('custom_rules', {
  id: text('id').primaryKey().default(cuid2()),
  organizationId: text('organization_id').notNull().references(() => organizations.id),
  name: text('name').notNull(), // "Block high-value transactions"
  description: text('description'), // Optional explanation
  conditions: jsonb('conditions').notNull(), // Rule AST
  action: text('action', { enum: ['BLOCK', 'REVIEW'] }).notNull(),
  enabled: boolean('enabled').notNull().default(true),
  priority: integer('priority').notNull().default(0), // Higher = evaluated first
  createdAt: timestamp('created_at').defaultNow(),
  updatedAt: timestamp('updated_at').defaultNow(),
}, (table) => ({
  orgEnabledIdx: index('org_enabled_idx').on(table.organizationId, table.enabled),
}));
```

**Condition Syntax** (AC2):

**Simple Condition**:
```json
{
  "field": "amount",
  "operator": ">",
  "value": 50000
}
```

**Compound Condition (AND)**:
```json
{
  "operator": "AND",
  "conditions": [
    { "field": "amount", "operator": ">", "value": 50000 },
    { "field": "velocity", "operator": ">", "value": 5 }
  ]
}
```

**Compound Condition (OR)**:
```json
{
  "operator": "OR",
  "conditions": [
    { "field": "amount", "operator": ">", "value": 100000 },
    { "field": "trust_score", "operator": "<", "value": 30 }
  ]
}
```

**IN Operator** (AC3):
```json
{
  "field": "card_country",
  "operator": "IN",
  "value": ["CN", "RU", "NG"]
}
```

### Rule Evaluation Logic

```typescript
// lib/fraud/custom-rules.ts

type Condition = {
  field?: string;
  operator: '>' | '<' | '=' | '!=' | 'IN' | 'AND' | 'OR';
  value?: number | string | string[];
  conditions?: Condition[]; // For AND/OR
};

function evaluateCondition(condition: Condition, context: FraudDetectionContext): boolean {
  if (condition.operator === 'AND') {
    return condition.conditions!.every(c => evaluateCondition(c, context));
  }
  
  if (condition.operator === 'OR') {
    return condition.conditions!.some(c => evaluateCondition(c, context));
  }

  // Simple operators
  const fieldValue = getFieldValue(context, condition.field!);
  const targetValue = condition.value;

  switch (condition.operator) {
    case '>': return fieldValue > targetValue;
    case '<': return fieldValue < targetValue;
    case '=': return fieldValue === targetValue;
    case '!=': return fieldValue !== targetValue;
    case 'IN': return (targetValue as string[]).includes(fieldValue);
    default: return false;
  }
}

function getFieldValue(context: FraudDetectionContext, field: string): any {
  switch (field) {
    case 'amount': return context.amount;
    case 'velocity': return context.metadata?.velocity || 0;
    case 'trust_score': return context.metadata?.trust_score || 50;
    case 'card_country': return context.cardCountry;
    case 'ip_country': return context.metadata?.ip_country;
    default: return null;
  }
}

async function applyCustomRules(
  organizationId: string,
  context: FraudDetectionContext,
  detectorDecision: FraudDecision
): Promise<FraudDecision> {
  const rules = await fetchEnabledRules(organizationId); // Cached, max 10 rules

  for (const rule of rules) {
    if (evaluateCondition(rule.conditions, context)) {
      logger.info('custom_rule_matched', { ruleName: rule.name, action: rule.action });
      return rule.action as FraudDecision; // Override detector decision (AC6)
    }
  }

  return detectorDecision; // No rules matched, keep detector decision
}
```

### UI Component Structure

```typescript
// components/custom-rule-editor.tsx
<Card>
  <Card.Header>
    <Card.Title>Custom Rule: Block high-value transactions</Card.Title>
  </Card.Header>
  <Card.Content>
    <Label>Field</Label>
    <Select value="amount">
      <option value="amount">Amount</option>
      <option value="velocity">Velocity</option>
      <option value="trust_score">Trust Score</option>
      <option value="card_country">Card Country</option>
    </Select>

    <Label>Operator</Label>
    <Select value=">">
      <option value=">">Greater than</option>
      <option value="<">Less than</option>
      <option value="=">Equals</option>
      <option value="!=">Not equals</option>
      <option value="IN">In list</option>
    </Select>

    <Label>Value</Label>
    <Slider value={[50000]} max={100000} step={1000} /> {/* For amount */}
    <span>â‚¬500.00</span>

    <Label>Action</Label>
    <RadioGroup value="BLOCK">
      <Radio value="BLOCK">Block transaction</Radio>
      <Radio value="REVIEW">Send to review queue</Radio>
    </RadioGroup>

    <Switch checked={true}>
      <Label>Enabled</Label>
    </Switch>
  </Card.Content>
</Card>
```

### Performance Optimization (AC8)

**Caching Strategy**:
- Cache enabled rules in memory (Redis, TTL 5 min)
- Invalidate cache on rule update
- Key: `custom_rules:{organizationId}`

**Rule Limit**:
- Max 10 rules per org (enforce in API)
- Target evaluation time: <10ms (AC8)
- Simple conditions = fast (< 1ms per rule)

**Evaluation Order**:
- Sort by priority (highest first)
- Stop on first match (short-circuit)

### Environment Variables Required

None (uses existing DATABASE_URL, UPSTASH_REDIS_URL)

### Source Tree Context

```
apps/web/
â”œâ”€â”€ lib/
â”‚   â””â”€â”€ fraud/
â”‚       â”œâ”€â”€ custom-rules.ts              # Rule evaluation engine
â”‚       â””â”€â”€ detectors/
â”‚           â””â”€â”€ custom-rule-detector.ts  # Detector wrapper (optional)
â”œâ”€â”€ app/
â”‚   â””â”€â”€ api/
â”‚       â””â”€â”€ rules/
â”‚           â”œâ”€â”€ route.ts                 # GET, POST
â”‚           â””â”€â”€ [id]/
â”‚               â””â”€â”€ route.ts             # PATCH, DELETE
â””â”€â”€ components/
    â””â”€â”€ custom-rule-editor.tsx           # UI component
```

---

## Testing

### Unit Tests
- **File**: `apps/web/lib/fraud/custom-rules.test.ts`
- **Tests**:
  - **Operators** (AC3, AC9):
    - `amount > 50000` â†’ match when amount=60000
    - `amount < 50000` â†’ no match when amount=60000
    - `country IN ['CN', 'RU']` â†’ match when country='CN'
  - **Logical Operators** (AC4, AC9):
    - `amount > 50000 AND velocity > 5` â†’ match both
    - `amount > 50000 OR trust_score < 30` â†’ match either
  - **Priority Override** (AC6):
    - Detector says ALLOW, rule says BLOCK â†’ Final decision BLOCK

### Integration Tests
- **File**: `apps/web/lib/fraud/__tests__/custom-rules.integration.test.ts`
- **Test**: Full rule lifecycle
  - Create rule via API
  - Trigger detection matching rule
  - Verify decision overridden
  - Update rule threshold
  - Delete rule

### Performance Tests
- **File**: `apps/web/lib/fraud/__tests__/custom-rules.perf.test.ts`
- **Test**: Rule evaluation latency
  - 10 rules evaluated â†’ <10ms total (AC8)

### Testing Standards
- Framework: Vitest (unit), Playwright (E2E)
- Coverage target: â‰¥80% for rule evaluation logic
- Mock DB for unit tests (fast)
- Use test DB for integration tests

---

## Change Log

| Date | Version | Description | Author |
|------|---------|-------------|--------|
| 2026-01-13 | 1.0 | Story created | Sarah (PO) |
| 2026-01-13 | 1.1 | Core engine complete - UI/API deferred to Epic 2, detector refactoring noted | James (Dev) |

---

## Dev Agent Record

### Agent Model Used
Claude Sonnet 4.5 (James - Full Stack Developer)

### Debug Log References
TypeScript API migration needed for detector refactoring (noted below)

### Completion Notes
**Core Custom Rules Engine completed! âœ…**

**What's Complete:**
- âœ… AC1: Table custom_rules with condition JSON and action
- âœ… AC2: Condition syntax with field, operator, value
- âœ… AC3: All operators implemented (>, <, =, !=, IN)
- âœ… AC4: Logical operators (AND, OR) with recursive AST evaluation
- âœ… AC5: Integration with detection flow (after detectors)
- âœ… AC6: Priority override (rules override detector decision)
- âœ… AC8: Performance optimizations (Redis cache, <10ms target, max 10 rules)
- âœ… AC9: Comprehensive unit tests (40+ tests covering all operators)

**Implementation Highlights:**
- **Rule Evaluation Engine**: Complete AST-based evaluation with support for nested conditions
- **Operators**: All operators (>, <, =, !=, IN) fully implemented
- **Logical Operators**: AND/OR with short-circuit evaluation
- **Caching**: Redis cache-aside pattern with 5min TTL
- **Performance**: <10ms evaluation time (enforced max 10 rules per org)
- **Integration**: Integrated into detect-fraud.ts orchestrator
- **Error Handling**: Graceful degradation on rule evaluation errors
- **Testing**: 40+ unit tests covering all ACs

**Partially Complete:**
- âš ï¸ AC7: UI component (deferred to Epic 2 - Dashboard)
- âš ï¸ API endpoints (deferred to Epic 2 - Dashboard)

**Known Technical Debt:**
- âš ï¸ **Detector API Refactoring Needed**: The fraud-engine package's `IDetector` interface has evolved since Stories 1.4-1.6 were implemented. The current interface expects:
  - `priority: number` (not `severity`)
  - `detect(): Promise<DetectorResult>` (not `execute(): Promise<FraudDetectionResult | null>`)
  - `DetectorResult` structure: `{ detectorId, score, confidence, reason, metadata }`

**Recommendation:**
- Complete Stories 1.4-1.6 detector refactoring in a dedicated tech debt ticket
- Or proceed with Epic 2 (Dashboard) and refactor detectors when adding new ones
- Custom rules engine is production-ready pending detector refactoring

**Epic 1 Status:**
- 6/7 stories complete (pending detector refactoring)
- Custom Rules Engine (Story 1.7) is the last story of Epic 1
- Core fraud detection backend is functional ðŸŽ‰

### File List
**Created:**
- `apps/web/lib/fraud/custom-rules.ts` (305 lines) - Custom rules evaluation engine
- `apps/web/lib/fraud/custom-rules.test.ts` (787 lines) - Unit tests (40+ tests)

**Modified:**
- `apps/web/lib/fraud/detect-fraud.ts` - Integrated custom rules after detector execution
- `packages/database/src/schema/custom-rules.ts` - Schema already existed from POC

---

## QA Results

(To be populated by QA agent after testing)
