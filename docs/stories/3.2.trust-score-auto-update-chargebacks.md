# Story 3.2: Trust Score Auto-Update sur Chargebacks

**Epic**: Epic 3 - Integration & Production Readiness  
**Story Points**: 3  
**Status**: Draft

---

## Story

**As a** system,  
**I want** trust scores to auto-update when chargebacks occur,  
**so that** fraudulent customers are penalized automatically.

---

## Acceptance Criteria

1. **AC1**: `charge.dispute.created` webhook handler
2. **AC2**: Trust score penalty application (-50 points)
3. **AC3**: Auto-blacklist logic pour repeat offenders (≥3 chargebacks)
4. **AC4**: Metadata enrichment (lastChargebackDate, totalChargebacks)
5. **AC5**: Cache invalidation
6. **AC6**: Unit test trust score logic

---

## Tasks / Subtasks

- [x] Add webhook handler for `charge.dispute.created` (AC1)
- [x] Extract customerId from dispute event (AC1)
- [x] Update trust score: -50 points (min 0) (AC2)
- [x] Increment totalChargebacks counter (AC4)
- [x] Auto-blacklist if totalChargebacks ≥ 3 (AC3)
- [x] Update metadata: lastChargebackDate (AC4)
- [x] Invalidate Redis cache (AC5)
- [x] Unit test: Verify -50 penalty, auto-blacklist logic (AC6)

---

## Dev Notes

### Context & Integration Points
This story adds a webhook handler for `charge.dispute.created` events (enabled in Story 3.1 AC6). When a chargeback occurs, the customer's trust score is automatically penalized. This integrates with:
- **Story 1.6**: Trust Score System (modifies `customer_trust_scores` table)
- **Story 3.1**: Webhook infrastructure (uses idempotency + retry logic)

**IMPORTANT**: Story 1.6 `customer_trust_scores` table needs migration to add chargeback tracking columns.

### File Structure
```
apps/web/
├── app/api/webhooks/stripe/
│   └── route.ts (MODIFY - add charge.dispute.created handler)
├── lib/
│   └── trust-score-updater.ts (NEW - chargeback penalty logic)
packages/database/
├── schema/
│   └── customer-trust-scores.ts (MODIFY - add chargeback columns)
└── migrations/
    └── 0009_add_chargeback_tracking.sql (NEW)
```

### Database Schema Changes

**Migration Required**: Add chargeback tracking columns to `customer_trust_scores` table

**Migration File**: `packages/database/migrations/0009_add_chargeback_tracking.sql`

```sql
-- Add chargeback tracking columns
ALTER TABLE customer_trust_scores 
ADD COLUMN total_chargebacks INTEGER DEFAULT 0 NOT NULL,
ADD COLUMN last_chargeback_date TIMESTAMP;

-- Index for performance
CREATE INDEX idx_customer_trust_scores_chargebacks 
  ON customer_trust_scores(total_chargebacks) 
  WHERE total_chargebacks >= 3;
```

**Updated Schema**:
```typescript
// packages/database/schema/customer-trust-scores.ts (MODIFY)
export const customerTrustScores = pgTable('customer_trust_scores', {
  id: text('id').primaryKey().$defaultFn(() => createId()),
  customerId: text('customer_id').notNull(),
  organizationId: text('organization_id').notNull().references(() => organizations.id),
  score: integer('score').default(50).notNull(), // 0-100
  isBlacklisted: boolean('is_blacklisted').default(false).notNull(),
  isWhitelisted: boolean('is_whitelisted').default(false).notNull(),
  
  // NEW: Chargeback tracking (Story 3.2)
  totalChargebacks: integer('total_chargebacks').default(0).notNull(),
  lastChargebackDate: timestamp('last_chargeback_date'),
  
  metadata: json('metadata'),
  createdAt: timestamp('created_at').defaultNow().notNull(),
  updatedAt: timestamp('updated_at').defaultNow().notNull(),
});
```

### Implementation Details

**Webhook Event Structure**:
```json
{
  "type": "charge.dispute.created",
  "data": {
    "object": {
      "id": "dp_xxx",
      "charge": "ch_xxx",
      "amount": 5000,
      "customer": "cus_xxx",
      "reason": "fraudulent"
    }
  }
}
```

**1. Webhook Handler** (AC1):
```typescript
// app/api/webhooks/stripe/route.ts (MODIFY)
export async function POST(request: Request) {
  // ... idempotency check from Story 3.1 ...
  
  // Event routing
  switch (event.type) {
    case 'payment_intent.created':
      await handlePaymentIntentCreated(event);
      break;
    case 'charge.dispute.created': // NEW
      await handleChargeDispute(event);
      break;
    // ... other handlers ...
  }
}

async function handleChargeDispute(event: Stripe.ChargeDisputeCreatedEvent) {
  const dispute = event.data.object;
  const customerId = dispute.customer as string;
  const chargeId = dispute.charge as string;
  
  // Get organizationId from charge metadata
  const charge = await stripe.charges.retrieve(chargeId);
  const organizationId = charge.metadata.organizationId;
  
  if (!organizationId) {
    console.error(`[Chargeback] No organizationId found for charge ${chargeId}`);
    return;
  }
  
  // Apply penalty
  await applyChargebackPenalty(customerId, organizationId);
}
```

**2. Trust Score Penalty Logic** (AC2, AC3, AC4):
```typescript
// lib/trust-score-updater.ts (NEW FILE)
export async function applyChargebackPenalty(
  customerId: string,
  organizationId: string
) {
  // AC2 & AC4: Update trust score with -50 penalty + metadata
  const updated = await db.update(customerTrustScores)
    .set({
      score: sql`GREATEST(score - 50, 0)`, // Min 0
      totalChargebacks: sql`total_chargebacks + 1`,
      lastChargebackDate: new Date(),
      updatedAt: new Date(),
    })
    .where(
      and(
        eq(customerTrustScores.customerId, customerId),
        eq(customerTrustScores.organizationId, organizationId)
      )
    )
    .returning();

  if (updated.length === 0) {
    // Customer trust score doesn't exist yet - create with penalty
    await db.insert(customerTrustScores).values({
      customerId,
      organizationId,
      score: 0, // Start at 0 due to chargeback
      totalChargebacks: 1,
      lastChargebackDate: new Date(),
    });
    console.log(`[Chargeback] Created trust score for ${customerId} with penalty`);
    return;
  }

  const customer = updated[0];
  console.log(`[Chargeback] Penalty applied: ${customerId}, new score: ${customer.score}, total chargebacks: ${customer.totalChargebacks}`);

  // AC3: Auto-blacklist if ≥3 chargebacks
  if (customer.totalChargebacks >= 3 && !customer.isBlacklisted) {
    await db.update(customerTrustScores)
      .set({ isBlacklisted: true })
      .where(
        and(
          eq(customerTrustScores.customerId, customerId),
          eq(customerTrustScores.organizationId, organizationId)
        )
      );
    
    console.warn(`[Chargeback] Auto-blacklisted: ${customerId} (${customer.totalChargebacks} chargebacks)`);
    
    // Optional: Send alert to merchant (Story 3.3 integration)
    posthog.capture('customer_auto_blacklisted', {
      customerId,
      organizationId,
      totalChargebacks: customer.totalChargebacks,
    });
  }

  // AC5: Invalidate Redis cache
  await redis.del(`trust:${organizationId}:${customerId}`);
  console.log(`[Chargeback] Cache invalidated for ${customerId}`);
}
```

**3. Atomic Transaction** (best practice):
```typescript
// Use Drizzle transaction for atomicity
await db.transaction(async (tx) => {
  // Update score + metadata
  const updated = await tx.update(customerTrustScores)
    .set({ ... })
    .where(...)
    .returning();
  
  // Auto-blacklist if needed
  if (updated[0].totalChargebacks >= 3) {
    await tx.update(customerTrustScores)
      .set({ isBlacklisted: true })
      .where(...);
  }
});
```

### Error Handling
- **Customer not found**: Create trust score with penalty (AC2)
- **Database error**: Logged, webhook will retry (Story 3.1)
- **Redis unavailable**: Log warning, continue (cache invalidation non-critical)

### Security Considerations
- Verify organizationId from charge metadata (multi-tenancy)
- No customer PII in logs (only customerId hashes)
- Auto-blacklist requires 3 chargebacks (prevents single false positive)

### Testing Standards

**Test File Locations**:
- Unit tests: `lib/__tests__/trust-score-updater.test.ts`
- Integration tests: `app/api/webhooks/stripe/__tests__/chargeback.integration.test.ts`

**Testing Framework**: Vitest

**Coverage Target**: 
- Unit: ≥80% for `trust-score-updater.ts`
- Integration: Covered in Story 3.6 webhook tests

**Test Cases** (AC6):
1. **Unit**: Apply -50 penalty → Score decreases (min 0)
2. **Unit**: First chargeback → totalChargebacks = 1
3. **Unit**: Third chargeback → Auto-blacklist triggered
4. **Unit**: Cache invalidation called
5. **Integration**: Stripe CLI `charge.dispute.created` → Trust score updated
6. **Integration**: 3 disputes in sequence → Customer blacklisted

---

## Testing

### Unit Tests (AC6)
- **Penalty application**: -50 points, minimum 0
- **Metadata update**: totalChargebacks increment, lastChargebackDate set
- **Auto-blacklist**: ≥3 chargebacks triggers isBlacklisted = true
- **Cache invalidation**: Redis key deleted
- **Transaction atomicity**: Score + blacklist update together

### Integration Tests (Story 3.6)
- Trigger `charge.dispute.created` → Verify DB update
- 3 sequential disputes → Verify auto-blacklist
- Cache invalidation → Verify key removed from Redis

---

## Change Log

| Date | Version | Description | Author |
|------|---------|-------------|--------|
| 2026-01-13 | 1.0 | Story created | Sarah (PO) |
| 2026-01-24 | 1.1 | Added DB migration, enhanced Dev Notes, added Testing Standards | Sarah (PO) |

---

## Dev Agent Record

### Agent Model Used
Claude Sonnet 4.5 (via Cursor)

### Implementation Summary
Implemented automatic trust score penalty when chargebacks occur. Added chargeback tracking columns (totalChargebacks, lastChargebackDate) to customer_trust_scores schema. Created trust-score-updater module that applies -50 point penalty, increments chargeback counter, and auto-blacklists customers with ≥3 chargebacks. Integrated charge.dispute.created webhook handler into webhook-processor. All unit tests passing (6/6).

### Completion Notes List
- Added totalChargebacks and lastChargebackDate columns to customer-trust-scores schema
- Created trust-score-updater.ts with applyChargebackPenalty function
- Updated webhook-processor.ts to handle charge.dispute.created events
- Implemented atomic transaction for score update + blacklist logic
- Added graceful Redis cache invalidation (non-blocking on failure)
- Adapted implementation to use existing schema structure (trustScore, status field instead of isBlacklisted boolean)
- All 6 unit tests passing

### File List
**Created:**
- `apps/web/lib/trust-score-updater.ts` - Chargeback penalty logic
- `apps/web/lib/__tests__/trust-score-updater.test.ts` - Unit tests (6 tests, all passing)

**Modified:**
- `packages/database/src/schema/customer-trust-scores.ts` - Added chargeback tracking columns
- `apps/web/lib/webhook-processor.ts` - Added handleChargeDispute function

### Debug Log References
- Chargeback processing: `[Chargeback] Penalty applied: {customerId}, new score: {score}, total chargebacks: {count}`
- Auto-blacklist: `[Chargeback] Auto-blacklisted: {customerId} ({count} chargebacks)`
- Cache invalidation: `[Chargeback] Cache invalidated for {customerId}`

---

## QA Results

(To be filled by QA Agent after implementation review)
