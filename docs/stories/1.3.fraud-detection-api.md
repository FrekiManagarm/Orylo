# Story 1.3: Fraud Detection API Endpoint

**Epic**: Epic 1 - Stripe Integration & Detection API  
**Story Points**: 8  
**Status**: ✅ Ready for Review

---

## Story

**As a** fraud detection system,  
**I want** a unified API endpoint that orchestrates all detectors and returns decision,  
**so that** webhook handler can call one function and get final result.

---

## Acceptance Criteria

1. **AC1**: Function: `detectFraud(context: DetectionContext): Promise<DetectionResult>`
2. **AC2**: Input: `DetectionContext` = payment intent data + customer data + metadata
3. **AC3**: Output: `DetectionResult` = decision (BLOCK/ALLOW/REVIEW), risk_score (0-100), detector_results[], confidence (0-1)
4. **AC4**: Decision logic: `risk_score ≥80 → BLOCK`, `20-79 → REVIEW`, `<20 → ALLOW`
5. **AC5**: Performance: P95 latency <350ms (measured via logging timestamps)
6. **AC6**: Error handling: If detector crashes → log error, continue with other detectors (partial detection)
7. **AC7**: Database write: Store `fraud_detections` record with all results
8. **AC8**: Unit test: Mock detectors, verify decision logic correct

---

## Tasks / Subtasks

- [x] **Task 1**: Create detection orchestrator (AC1, AC2, AC3)
  - [x] Create `lib/fraud/detect-fraud.ts` with `detectFraud()` function
  - [x] Accept `FraudDetectionContext` input (AC2)
  - [x] Instantiate `FraudDetectionEngine` from `@orylo/fraud-engine`
  - [x] Call `engine.detect(context)` to run all detectors
  - [x] Return `FraudDetectionResult` (AC3)

- [x] **Task 2**: Implement decision logic (AC4)
  - [x] Calculate final `risk_score` from detector results
  - [x] Apply thresholds: ≥80 = BLOCK, 20-79 = REVIEW, <20 = ALLOW (AC4)
  - [x] Calculate `confidence` score (0-1) based on detector agreement

- [x] **Task 3**: Error handling for detector failures (AC6)
  - [x] Wrap each detector execution in try-catch
  - [x] Log error: `detector_execution_error` with detector ID
  - [x] Continue with other detectors (graceful degradation)
  - [x] Mark failed detectors in metadata: `{status: 'failed', error: message}`

- [x] **Task 4**: Performance monitoring (AC5)
  - [x] Log timestamp before detection: `detection_start`
  - [x] Log timestamp after detection: `detection_complete`
  - [x] Calculate latency: `end - start`
  - [x] Log latency: `detection_latency_ms` (INFO level)
  - [x] Alert if latency >350ms (WARN level)

- [x] **Task 5**: Database persistence (AC7)
  - [x] Create DB insert: `fraud_detections` table
  - [x] Store: organizationId, paymentIntentId, decision, risk_score, detector_results[], confidence, latency_ms
  - [x] Use Drizzle ORM: `db.insert(fraudDetections).values(...)`
  - [x] Handle DB errors (log, don't crash detection)

- [x] **Task 6**: Unit tests (AC8)
  - [x] Mock detector results (high/medium/low risk)
  - [x] Verify decision logic correct for all thresholds
  - [x] Test error handling (detector crash scenarios)
  - [x] Test performance (latency measurement)

---

## Dev Notes

### Relevant Architecture

**Fraud Detection Engine** (POC validated):
- Package: `@orylo/fraud-engine`
- Interface: `IDetector` for pluggable detectors
- Scoring: `IScoringStrategy` (currently `AdditiveScoringStrategy`)

**Detection Context** (ADR-005 Branded Types):
```typescript
interface FraudDetectionContext {
  organizationId: OrganizationId;
  paymentIntentId: PaymentIntentId;
  amount: number; // cents
  currency: string; // ISO 4217
  customerEmail: string | null;
  customerIp: string | null;
  cardCountry: string | null; // ISO 3166-1 alpha-2
  cardLast4: string | null;
  metadata: Record<string, unknown>;
  timestamp: Date;
}
```

**Decision Logic** (ADR-004):
- **BLOCK** (risk_score ≥80): Auto-decline, no manual review
- **REVIEW** (risk_score 20-79): Queue for manual review
- **ALLOW** (risk_score <20): Auto-approve, low risk

**Database Schema**:
```typescript
// packages/database/src/schema/fraud-detections.ts
export const fraudDetections = pgTable('fraud_detections', {
  id: text('id').primaryKey().default(cuid2()),
  organizationId: text('organization_id').notNull().references(() => organizations.id),
  paymentIntentId: text('payment_intent_id').notNull(),
  decision: text('decision', { enum: ['BLOCK', 'ALLOW', 'REVIEW'] }).notNull(),
  riskScore: integer('risk_score').notNull(), // 0-100
  confidence: real('confidence').notNull(), // 0-1
  detectorResults: jsonb('detector_results').notNull(), // array of detector outputs
  latencyMs: integer('latency_ms'),
  createdAt: timestamp('created_at').defaultNow(),
});
```

### Performance Targets

| Detector | Target Latency | Critical? |
|----------|----------------|-----------|
| **Velocity** | <10ms (Redis lookup) | Yes |
| **Geolocation** | <5ms (local MaxMind DB) | Yes |
| **Trust Score** | <20ms (Redis + DB) | Yes |
| **IP Reputation** | <50ms (external API) | Optional |
| **Device Fingerprint** | <30ms (external API) | Optional |
| **Payment Patterns** | <20ms (DB query) | Optional |
| **Chargeback History** | <10ms (DB query) | Optional |
| **Total P95** | <350ms | **Critical** |

### Error Handling Strategy

**Graceful Degradation**:
- If 1 detector fails → Continue with 6 remaining
- If >3 detectors fail → Log WARNING, decision based on available data
- If ALL detectors fail → Return REVIEW (manual check), log CRITICAL

**Logging**:
```typescript
logger.info('detection_start', { paymentIntentId, organizationId });
logger.info('detector_executed', { detectorId, score, latency });
logger.error('detector_failed', { detectorId, error: e.message });
logger.info('detection_complete', { decision, riskScore, latency });
```

### Source Tree Context

```
apps/web/
├── lib/
│   └── fraud/
│       ├── detect-fraud.ts        # Main detection orchestrator
│       └── scoring.ts             # Decision logic (thresholds)
└── app/
    └── api/
        └── webhooks/
            └── stripe/
                └── route.ts        # Calls detectFraud()
```

---

## Testing

### Unit Tests
- **File**: `apps/web/lib/fraud/detect-fraud.test.ts`
- **Tests**:
  - **Decision Logic** (AC4):
    - `risk_score=90 → BLOCK`
    - `risk_score=50 → REVIEW`
    - `risk_score=10 → ALLOW`
  - **Error Handling** (AC6):
    - Detector crash → Continue with others
    - All detectors crash → Return REVIEW
  - **Performance** (AC5):
    - Latency measured correctly
    - Log entries created

### Integration Tests
- **File**: `apps/web/lib/fraud/__tests__/detect-fraud.integration.test.ts`
- **Test**: Full detection flow with real database
  - Insert detection result to DB (AC7)
  - Verify all fields stored correctly
  - Query detection by paymentIntentId

### E2E Tests (Story 3.7)
- **File**: `e2e/fraud-detection.spec.ts` (Playwright)
- **Test**: Webhook triggers detection → Result in dashboard

### Testing Standards
- Framework: Vitest (unit), Playwright (E2E)
- Coverage target: ≥80% for detection logic
- Mock all detectors (fast, deterministic tests)
- Test boundary conditions (score=0, 20, 79, 80, 100)

---

## Change Log

| Date | Version | Description | Author |
|------|---------|-------------|--------|
| 2026-01-13 | 1.0 | Story created | Sarah (PO) |
| 2026-01-13 | 1.1 | Implementation completed - All tasks & tests done | James (Dev) |

---

## Dev Agent Record

### Agent Model Used
Claude Sonnet 4.5 (James - Full Stack Developer)

### Debug Log References
No debug logs required - implementation proceeded smoothly

### Completion Notes
**All tasks completed successfully! ✅**

- **Detection Orchestrator**: Complete `detectFraud()` function in `lib/fraud/detect-fraud.ts`
- **Decision Logic**: Thresholds implemented: ≥80=BLOCK, 20-79=REVIEW, <20=ALLOW (AC4)
- **Error Handling**: Graceful degradation with try-catch, continues if detectors fail (AC6)
- **Performance Monitoring**: Complete latency tracking with start/end timestamps (AC5)
- **Database Persistence**: Stores all detection results to `fraud_detections` table (AC7)
- **Confidence Calculation**: Based on detector coverage and agreement
- **Webhook Integration**: Updated webhook handler to call `detectFraud()` (Story 1.2 integration)
- **Testing**: Comprehensive unit tests (14 tests) and integration tests

**Acceptance Criteria Status:**
- ✅ AC1: Function `detectFraud(context)` returns `DetectionResult`
- ✅ AC2: Input `DetectionContext` with payment + customer data
- ✅ AC3: Output `DetectionResult` with decision, risk_score, detector_results, confidence
- ✅ AC4: Decision logic: ≥80=BLOCK, 20-79=REVIEW, <20=ALLOW
- ✅ AC5: Performance monitoring with latency <350ms target
- ✅ AC6: Error handling with graceful degradation
- ✅ AC7: Database write to `fraud_detections` table
- ✅ AC8: Unit tests with mocked detectors

**Integration Notes:**
- ✅ Story 1.2 webhook handler now calls `detectFraud()` asynchronously
- ✅ Story 1.4-1.7: Ready for detector implementations (velocity, geolocation, trust score, custom rules)
- ✅ Story 2.1: Database queries ready for dashboard feed

**Ready for Code Review & Testing**

### File List
**Created:**
- `apps/web/lib/fraud/detect-fraud.ts` (259 lines) - Main detection orchestrator
- `apps/web/lib/fraud/detect-fraud.test.ts` (307 lines) - Unit tests (14 tests)
- `apps/web/lib/fraud/__tests__/detect-fraud.integration.test.ts` (286 lines) - Integration tests

**Modified:**
- `apps/web/app/api/webhooks/stripe/route.ts` - Integrated `detectFraud()` call in webhook handler

---

## QA Results

(To be populated by QA agent after testing)
