# Story 2.15: SSE Production Improvements & Rate Limiting

**Epic**: Epic 2 - Dashboard Action-First Experience  
**Story Points**: 5  
**Status**: ðŸ“‹ Ready

---

## Story

**As a** system administrator,  
**I want** SSE connections to be rate-limited and monitored,  
**so that** the system can handle production load gracefully and prevent resource exhaustion.

---

## Acceptance Criteria

1. **AC1**: Rate limiting: Max 100 concurrent SSE connections per organization (enforce at endpoint level)
2. **AC2**: Connection tracking: Track active SSE connections in Redis (key: `sse:connections:{organizationId}`, TTL: 1h)
3. **AC3**: Graceful rejection: Return HTTP 429 (Too Many Requests) when limit exceeded, with retry-after header
4. **AC4**: Monitoring: Log connection open/close events with metrics (connection count, duration)
5. **AC5**: Support `detection.updated` events: Poll for updated detections (when explanation generated, suggestion accepted, etc.)
6. **AC6**: E2E test: Verify SSE rate limiting works (100 connections max, 101st returns 429)
7. **AC7**: Performance: Connection tracking overhead <10ms per request

---

## Tasks / Subtasks

- [ ] **Task 1**: Implement rate limiting for SSE connections (AC1, AC3)
  - [ ] Create Redis-based connection counter (key: `sse:connections:{organizationId}`)
  - [ ] Check connection count before opening SSE stream
  - [ ] Increment counter on connection open
  - [ ] Decrement counter on connection close (cleanup)
  - [ ] Return HTTP 429 with retry-after header when limit exceeded
  - [ ] Use `@upstash/ratelimit` pattern (similar to other rate limiters)

- [ ] **Task 2**: Connection tracking and monitoring (AC2, AC4)
  - [ ] Track active connections in Redis (increment/decrement on open/close)
  - [ ] Log connection events: `[SSE] Connection opened`, `[SSE] Connection closed`
  - [ ] Include metrics: `organizationId`, `activeConnections`, `connectionDuration`
  - [ ] Set TTL on Redis keys (1h) to handle cleanup on crashes

- [ ] **Task 3**: Support detection.updated events (AC5)
  - [ ] Track `updatedAt` timestamp for detections (if not exists, use `createdAt`)
  - [ ] Poll for updated detections since last check (query with `updatedAt >= lastCheck`)
  - [ ] Send `detection.updated` events via SSE when detections are updated
  - [ ] Update `useSSE` hook to handle `detection.updated` events (already implemented)

- [ ] **Task 4**: E2E tests (AC6)
  - [ ] Test: Open 100 SSE connections â†’ All succeed
  - [ ] Test: Open 101st SSE connection â†’ Returns 429
  - [ ] Test: Close one connection â†’ 101st connection now succeeds
  - [ ] Test: Verify `detection.updated` events are sent when detection updated

---

## Dependencies

**Depends on**:
- Story 2.10: SSE endpoint and `useSSE` hook (already implemented)
- Epic 3: Redis configured (ADR-003)
- Story 4.2: AI explanations (for `detection.updated` events when explanation generated)

**Blocks**:
- None

**Can be developed in parallel with**:
- Epic 3 stories (no shared dependencies)

---

## Dev Notes

### Relevant Architecture

**Rate Limiting Strategy**:
```typescript
// lib/rate-limit.ts
import { Ratelimit } from "@upstash/ratelimit";
import { redis } from "@/lib/redis";

// SSE connection limit: 100 concurrent per organization
export const sseConnectionRateLimit = new Ratelimit({
  redis,
  limiter: Ratelimit.slidingWindow(100, "1 m"), // Max 100 concurrent
  analytics: true,
  prefix: "ratelimit:sse:connections",
});

// Usage in /api/events/route.ts
const rateLimitResult = await sseConnectionRateLimit.limit(organizationId);
if (!rateLimitResult.success) {
  return new Response("Too Many Requests", {
    status: 429,
    headers: {
      "Retry-After": "60", // Retry after 60 seconds
    },
  });
}
```

**Connection Tracking**:
```typescript
// Track active connections in Redis
const connectionKey = `sse:connections:${organizationId}`;

// On connection open
await redis.incr(connectionKey);
await redis.expire(connectionKey, 3600); // 1h TTL

// On connection close
await redis.decr(connectionKey);
```

**Detection Updated Events**:
```typescript
// Poll for updated detections
const updatedDetections = await db
  .select()
  .from(fraudDetections)
  .where(
    and(
      eq(fraudDetections.organizationId, organizationId),
      gte(fraudDetections.updatedAt, new Date(lastUpdateCheck)) // Use updatedAt
    )
  );

// Send detection.updated events
for (const detection of updatedDetections) {
  controller.enqueue(
    encoder.encode(
      `event: detection.updated\ndata: ${JSON.stringify(detection)}\n\n`
    )
  );
}
```

**Integration Points**:
- Uses Redis for connection tracking (Epic 3, ADR-003)
- Uses `@upstash/ratelimit` pattern (ADR-010 Layer 6)
- Integrates with existing SSE endpoint (`/api/events`)
- Uses existing `useSSE` hook (already supports `detection.updated` events)
- **ADR References**: ADR-003 (Cache Architecture), ADR-008 (Real-Time Strategy), ADR-010 (Security Architecture)

**Security & Multi-Tenancy** (ADR-010):
- Rate limiting per organization (not global)
- Connection tracking isolated by `organizationId`
- Verify Better Auth session before rate limit check
- Return 429 with retry-after header (standard HTTP behavior)

**Performance Considerations**:
- Redis operations: `INCR`/`DECR` are O(1), overhead <1ms
- Connection tracking adds <10ms overhead per request
- Rate limit check adds <5ms overhead (Redis lookup)
- Total overhead: <15ms per SSE connection (acceptable)

### Source Tree Context

```
apps/web/
â”œâ”€â”€ lib/
â”‚   â””â”€â”€ rate-limit.ts                    # Add SSE connection rate limiter
â”œâ”€â”€ app/
â”‚   â””â”€â”€ api/
â”‚       â””â”€â”€ events/
â”‚           â””â”€â”€ route.ts                 # Add rate limiting and detection.updated support
â””â”€â”€ e2e/
    â””â”€â”€ sse-rate-limiting.spec.ts       # E2E tests for rate limiting
```

---

## Testing

### Unit Tests
- **File**: `apps/web/lib/rate-limit.test.ts`
- **Tests**:
  - SSE connection rate limiter increments/decrements correctly
  - Rate limit returns 429 when limit exceeded
  - Connection tracking in Redis works correctly

### Integration Tests
- **File**: `apps/web/app/api/events/__tests__/route.integration.test.ts`
- **Tests**:
  - Rate limiting enforced at endpoint level
  - Connection tracking works (increment on open, decrement on close)
  - `detection.updated` events sent when detection updated

### E2E Tests
- **File**: `e2e/sse-rate-limiting.spec.ts` (Playwright)
- **Tests**:
  - Open 100 SSE connections â†’ All succeed
  - Open 101st connection â†’ Returns 429
  - Close one connection â†’ 101st connection now succeeds
  - Verify `detection.updated` events received when detection updated

### Testing Standards
- Framework: Vitest (unit/integration), Playwright (E2E)
- Coverage target: â‰¥80% for rate limiting logic
- Mock Redis for unit tests
- Use real Redis for integration tests (requires REDIS_URL)

---

## Change Log

| Date | Version | Description | Author |
|------|---------|-------------|--------|
| 2026-02-01 | 1.0 | Story created | Dev Agent |

---

## Dev Agent Record

### Agent Model Used
N/A (Story not yet implemented)

### Completion Notes List
(To be populated after implementation)

### File List
(To be populated after implementation)

---

## QA Results

(To be populated by QA agent after testing)
