# Story 3.6: Integration Tests - API & Webhooks

**Epic**: Epic 3 - Integration & Production Readiness  
**Story Points**: 5  
**Status**: Draft

---

## Story

**As a** development team,  
**I want** comprehensive integration tests for API and webhooks,  
**so that** we catch integration bugs before production.

---

## Acceptance Criteria

1. **AC1**: Test setup avec test database (Neon branch or SQLite)
2. **AC2**: Integration test: POST /api/webhooks/stripe (valid, duplicate, invalid sig)
3. **AC3**: Integration test: GET /api/detections (filters, pagination)
4. **AC4**: Integration test: POST /api/customers/[id]/block
5. **AC5**: Integration test: Trust score update flow
6. **AC6**: Test coverage integration (≥60% apps/web/app/api/**)
7. **AC7**: CI/CD integration (GitHub Actions)

---

## Tasks / Subtasks

- [x] Setup test database (Neon branch or in-memory SQLite)
- [x] Integration test: Webhook valid signature → Processing
- [x] Integration test: Webhook duplicate event → Idempotency
- [x] Integration test: Webhook invalid signature → 400 error
- [x] Integration test: GET /api/detections with filters
- [x] Integration test: POST /api/customers/[id]/block → DB update
- [x] Integration test: Trust score update after detection
- [x] Coverage report: ≥60% for app/api/**
- [x] GitHub Actions: Run integration tests on PR

---

## Dev Notes

### Context & Integration Points
This story establishes comprehensive integration testing for all API routes and webhooks implemented in Epics 1-3. Tests verify end-to-end flows including authentication, database operations, external API calls (Stripe), and multi-tenancy enforcement.

**Dependencies**: Requires Stories 3.1 (webhooks), 3.2 (trust score), 2.7/2.8 (block/whitelist) to be implemented first.

### File Structure
```
apps/web/
├── vitest.config.integration.ts (NEW - integration test config)
├── test/
│   ├── setup-integration.ts (NEW - test DB setup)
│   ├── helpers/
│   │   ├── stripe-fixtures.ts (NEW - test webhook payloads)
│   │   └── auth-helpers.ts (NEW - test session creation)
│   └── fixtures/
│       └── webhook-events.json (NEW - sample events)
├── app/api/
│   ├── webhooks/stripe/
│   │   └── __tests__/
│   │       ├── route.integration.test.ts (NEW)
│   │       └── idempotency.integration.test.ts (NEW)
│   ├── detections/
│   │   └── __tests__/
│   │       └── route.integration.test.ts (NEW)
│   ├── customers/
│   │   └── [id]/
│   │       └── __tests__/
│   │           └── block.integration.test.ts (NEW)
│   └── cron/data-retention/
│       └── __tests__/
│           └── route.integration.test.ts (NEW)
.github/workflows/
└── test-integration.yml (NEW)
```

### Part 1: Test Database Setup (AC1)

**Vitest Integration Config**:
```typescript
// vitest.config.integration.ts (NEW FILE)
import { defineConfig } from 'vitest/config';
import path from 'path';

export default defineConfig({
  test: {
    name: 'integration',
    environment: 'node',
    setupFiles: ['./test/setup-integration.ts'],
    include: ['**/*.integration.test.ts'],
    testTimeout: 30000, // 30s for DB operations
    coverage: {
      provider: 'v8',
      reporter: ['text', 'json', 'html'],
      include: ['app/api/**/*.ts'],
      exclude: ['**/__tests__/**', '**/*.test.ts'],
      thresholds: {
        lines: 60,
        functions: 60,
        branches: 60,
        statements: 60,
      },
    },
  },
  resolve: {
    alias: {
      '@': path.resolve(__dirname, './'),
      '@db': path.resolve(__dirname, '../../packages/database'),
    },
  },
});
```

**Test Database Setup** (Using Neon Branching):
```typescript
// test/setup-integration.ts (NEW FILE)
import { beforeAll, afterAll, afterEach } from 'vitest';
import { db } from '@/lib/db';
import { sql } from 'drizzle-orm';
import { fraudDetections, customerTrustScores, webhookEvents, organizations } from '@db/schema';

// AC1: Use Neon branch for testing (recommended) or SQLite
const TEST_DATABASE_URL = process.env.TEST_DATABASE_URL || process.env.DATABASE_URL;

beforeAll(async () => {
  // Set test database URL
  process.env.DATABASE_URL = TEST_DATABASE_URL;
  
  console.log('[Test Setup] Initializing test database');
  
  // Run migrations on test DB
  // await migrate(db, { migrationsFolder: '../../packages/database/migrations' });
});

afterEach(async () => {
  // Clean up after each test to ensure isolation
  await db.delete(fraudDetections);
  await db.delete(customerTrustScores);
  await db.delete(webhookEvents);
  // Keep organizations (seed data)
});

afterAll(async () => {
  console.log('[Test Setup] Cleaning up test database');
  // Optionally drop test database or leave for inspection
});
```

**Test Fixtures**:
```typescript
// test/helpers/stripe-fixtures.ts (NEW FILE)
import Stripe from 'stripe';
import crypto from 'crypto';

export function createTestWebhookEvent(
  type: string = 'payment_intent.created',
  overrides: Partial<Stripe.Event> = {}
): Stripe.Event {
  return {
    id: `evt_test_${Date.now()}`,
    object: 'event',
    api_version: '2023-10-16',
    created: Math.floor(Date.now() / 1000),
    type,
    data: {
      object: {
        id: `pi_test_${crypto.randomBytes(8).toString('hex')}`,
        object: 'payment_intent',
        amount: 5000,
        currency: 'usd',
        customer: 'cus_test_123',
        metadata: {
          organizationId: 'org_test_123',
        },
        ...overrides.data?.object,
      } as Stripe.PaymentIntent,
    },
    livemode: false,
    pending_webhooks: 1,
    request: { id: null, idempotency_key: null },
    ...overrides,
  } as Stripe.Event;
}

export function generateStripeSignature(
  payload: string,
  secret: string = process.env.STRIPE_WEBHOOK_SECRET || 'whsec_test'
): string {
  const timestamp = Math.floor(Date.now() / 1000);
  const signedPayload = `${timestamp}.${payload}`;
  const signature = crypto
    .createHmac('sha256', secret)
    .update(signedPayload)
    .digest('hex');
  
  return `t=${timestamp},v1=${signature}`;
}
```

**Auth Helpers**:
```typescript
// test/helpers/auth-helpers.ts (NEW FILE)
import { auth } from '@/lib/auth';

export async function createTestSession(organizationId: string = 'org_test_123') {
  // Create test user session
  const session = await auth.api.signInEmail({
    email: 'test@example.com',
    password: 'test-password',
    callbackURL: '/',
  });
  
  return session;
}

export function getAuthHeaders(sessionToken: string): HeadersInit {
  return {
    'Cookie': `better-auth.session_token=${sessionToken}`,
  };
}
```

### Part 2: Webhook Integration Tests (AC2)

```typescript
// app/api/webhooks/stripe/__tests__/route.integration.test.ts (NEW FILE)
import { describe, it, expect, beforeEach } from 'vitest';
import { db } from '@/lib/db';
import { fraudDetections, webhookEvents } from '@db/schema';
import { createTestWebhookEvent, generateStripeSignature } from '@/test/helpers/stripe-fixtures';
import { eq } from 'drizzle-orm';

describe('POST /api/webhooks/stripe - Integration', () => {
  let testOrgId: string;

  beforeEach(() => {
    testOrgId = 'org_test_' + Date.now();
  });

  it('AC2: processes valid payment_intent.created webhook', async () => {
    // Create test webhook event
    const event = createTestWebhookEvent('payment_intent.created', {
      data: {
        object: {
          metadata: { organizationId: testOrgId },
        },
      },
    });

    const payload = JSON.stringify(event);
    const signature = generateStripeSignature(payload);

    // Send webhook request
    const response = await fetch('http://localhost:3000/api/webhooks/stripe', {
      method: 'POST',
      body: payload,
      headers: {
        'Content-Type': 'application/json',
        'stripe-signature': signature,
      },
    });

    expect(response.status).toBe(200);
    const json = await response.json();
    expect(json.received).toBe(true);

    // Verify detection created in database
    const detections = await db.select()
      .from(fraudDetections)
      .where(eq(fraudDetections.organizationId, testOrgId))
      .limit(1);

    expect(detections.length).toBe(1);
    expect(detections[0].paymentIntentId).toBe(event.data.object.id);
    expect(detections[0].decision).toMatch(/allow|review|block/);
  });

  it('AC2: detects duplicate events (idempotency)', async () => {
    const event = createTestWebhookEvent('payment_intent.created', {
      data: { object: { metadata: { organizationId: testOrgId } } },
    });

    const payload = JSON.stringify(event);
    const signature = generateStripeSignature(payload);

    // Send webhook twice
    const response1 = await fetch('http://localhost:3000/api/webhooks/stripe', {
      method: 'POST',
      body: payload,
      headers: { 'Content-Type': 'application/json', 'stripe-signature': signature },
    });

    const response2 = await fetch('http://localhost:3000/api/webhooks/stripe', {
      method: 'POST',
      body: payload,
      headers: { 'Content-Type': 'application/json', 'stripe-signature': signature },
    });

    expect(response1.status).toBe(200);
    expect(response2.status).toBe(200);

    const json2 = await response2.json();
    expect(json2.duplicate).toBe(true);

    // Verify only ONE detection created
    const detections = await db.select()
      .from(fraudDetections)
      .where(eq(fraudDetections.organizationId, testOrgId));

    expect(detections.length).toBe(1);
  });

  it('AC2: rejects invalid signature', async () => {
    const event = createTestWebhookEvent();
    const payload = JSON.stringify(event);

    // Invalid signature
    const response = await fetch('http://localhost:3000/api/webhooks/stripe', {
      method: 'POST',
      body: payload,
      headers: {
        'Content-Type': 'application/json',
        'stripe-signature': 'invalid_signature',
      },
    });

    expect(response.status).toBe(400);
  });
});
```

### Part 3: Detections API Tests (AC3)

```typescript
// app/api/detections/__tests__/route.integration.test.ts (NEW FILE)
import { describe, it, expect, beforeEach } from 'vitest';
import { db } from '@/lib/db';
import { fraudDetections } from '@db/schema';
import { createTestSession, getAuthHeaders } from '@/test/helpers/auth-helpers';

describe('GET /api/detections - Integration', () => {
  let authHeaders: HeadersInit;
  let testOrgId: string;

  beforeEach(async () => {
    testOrgId = 'org_test_' + Date.now();
    const session = await createTestSession(testOrgId);
    authHeaders = getAuthHeaders(session.token);

    // Seed test data
    await db.insert(fraudDetections).values([
      {
        organizationId: testOrgId,
        paymentIntentId: 'pi_1',
        decision: 'allow',
        riskScore: 20,
        amount: 5000,
        currency: 'usd',
        customerId: 'cus_1',
        customerEmail: 'test1@example.com',
      },
      {
        organizationId: testOrgId,
        paymentIntentId: 'pi_2',
        decision: 'block',
        riskScore: 95,
        amount: 10000,
        currency: 'usd',
        customerId: 'cus_2',
        customerEmail: 'test2@example.com',
      },
    ]);
  });

  it('AC3: returns all detections for organization', async () => {
    const response = await fetch('http://localhost:3000/api/detections', {
      headers: authHeaders,
    });

    expect(response.status).toBe(200);
    const json = await response.json();
    
    expect(json.detections).toHaveLength(2);
    expect(json.detections[0].organizationId).toBe(testOrgId);
  });

  it('AC3: filters by decision', async () => {
    const response = await fetch('http://localhost:3000/api/detections?decision=block', {
      headers: authHeaders,
    });

    expect(response.status).toBe(200);
    const json = await response.json();
    
    expect(json.detections).toHaveLength(1);
    expect(json.detections[0].decision).toBe('block');
  });

  it('AC3: respects pagination limit', async () => {
    const response = await fetch('http://localhost:3000/api/detections?limit=1', {
      headers: authHeaders,
    });

    expect(response.status).toBe(200);
    const json = await response.json();
    
    expect(json.detections).toHaveLength(1);
  });

  it('AC3: enforces multi-tenancy', async () => {
    // Create detection for another org
    const otherOrgId = 'org_other_123';
    await db.insert(fraudDetections).values({
      organizationId: otherOrgId,
      paymentIntentId: 'pi_3',
      decision: 'allow',
      riskScore: 50,
      amount: 3000,
      currency: 'usd',
      customerId: 'cus_3',
      customerEmail: 'other@example.com',
    });

    // Request with testOrgId session
    const response = await fetch('http://localhost:3000/api/detections', {
      headers: authHeaders,
    });

    const json = await response.json();
    
    // Should NOT include other org's detection
    expect(json.detections).toHaveLength(2);
    expect(json.detections.every(d => d.organizationId === testOrgId)).toBe(true);
  });
});
```

### Part 4: Block Customer Tests (AC4)

```typescript
// app/api/customers/[id]/__tests__/block.integration.test.ts (NEW FILE)
import { describe, it, expect, beforeEach } from 'vitest';
import { db } from '@/lib/db';
import { customerTrustScores } from '@db/schema';
import { createTestSession, getAuthHeaders } from '@/test/helpers/auth-helpers';
import { eq, and } from 'drizzle-orm';

describe('POST /api/customers/[id]/block - Integration', () => {
  let authHeaders: HeadersInit;
  let testOrgId: string;
  const customerId = 'cus_test_block';

  beforeEach(async () => {
    testOrgId = 'org_test_' + Date.now();
    const session = await createTestSession(testOrgId);
    authHeaders = getAuthHeaders(session.token);

    // Seed trust score
    await db.insert(customerTrustScores).values({
      organizationId: testOrgId,
      customerId,
      score: 50,
      isBlacklisted: false,
      isWhitelisted: false,
    });
  });

  it('AC4: blocks customer and updates trust score', async () => {
    const response = await fetch(`http://localhost:3000/api/customers/${customerId}/block`, {
      method: 'POST',
      headers: authHeaders,
    });

    expect(response.status).toBe(200);
    const json = await response.json();
    expect(json.blocked).toBe(true);

    // Verify database update
    const trustScore = await db.select()
      .from(customerTrustScores)
      .where(
        and(
          eq(customerTrustScores.customerId, customerId),
          eq(customerTrustScores.organizationId, testOrgId)
        )
      )
      .limit(1);

    expect(trustScore[0].isBlacklisted).toBe(true);
    expect(trustScore[0].score).toBe(0); // Story 2.7: Score set to 0
  });
});
```

### Part 5: Trust Score Flow Tests (AC5)

```typescript
// lib/__tests__/trust-score-flow.integration.test.ts (NEW FILE)
import { describe, it, expect } from 'vitest';
import { detectFraud } from '@/lib/detector';
import { db } from '@/lib/db';
import { customerTrustScores } from '@db/schema';
import { eq, and } from 'drizzle-orm';

describe('Trust Score Update Flow - Integration', () => {
  it('AC5: creates trust score on first transaction', async () => {
    const orgId = 'org_test_' + Date.now();
    const customerId = 'cus_new_customer';

    // First transaction for new customer
    const result = await detectFraud({
      organizationId: orgId,
      customerId,
      amount: 5000,
      currency: 'usd',
      ipAddress: '192.168.1.1',
      paymentIntentId: 'pi_test_123',
    });

    expect(result.decision).toBeDefined();

    // Verify trust score created
    const trustScores = await db.select()
      .from(customerTrustScores)
      .where(
        and(
          eq(customerTrustScores.customerId, customerId),
          eq(customerTrustScores.organizationId, orgId)
        )
      );

    expect(trustScores.length).toBe(1);
    expect(trustScores[0].score).toBeGreaterThanOrEqual(0);
    expect(trustScores[0].score).toBeLessThanOrEqual(100);
  });
});
```

### Part 6: Coverage Configuration (AC6)

```json
// package.json (MODIFY - add test scripts)
{
  "scripts": {
    "test:unit": "vitest run --config vitest.config.ts",
    "test:integration": "vitest run --config vitest.config.integration.ts",
    "test:all": "bun run test:unit && bun run test:integration",
    "test:coverage": "vitest run --config vitest.config.integration.ts --coverage",
    "test:watch": "vitest --config vitest.config.integration.ts"
  }
}
```

### Part 7: CI/CD Integration (AC7)

```yaml
# .github/workflows/test-integration.yml (NEW FILE)
name: Integration Tests

on:
  pull_request:
    branches: [main, develop]
  push:
    branches: [main]

jobs:
  integration-tests:
    runs-on: ubuntu-latest
    
    services:
      postgres:
        image: postgres:15
        env:
          POSTGRES_USER: test
          POSTGRES_PASSWORD: test
          POSTGRES_DB: orylo_test
        options: >-
          --health-cmd pg_isready
          --health-interval 10s
          --health-timeout 5s
          --health-retries 5
        ports:
          - 5432:5432
      
      redis:
        image: redis:7-alpine
        options: >-
          --health-cmd "redis-cli ping"
          --health-interval 10s
          --health-timeout 5s
          --health-retries 5
        ports:
          - 6379:6379

    steps:
      - name: Checkout code
        uses: actions/checkout@v3

      - name: Setup Bun
        uses: oven-sh/setup-bun@v1
        with:
          bun-version: latest

      - name: Install dependencies
        run: bun install

      - name: Run database migrations
        run: bun run db:migrate
        env:
          DATABASE_URL: postgresql://test:test@localhost:5432/orylo_test

      - name: Run integration tests
        run: bun run test:integration
        env:
          DATABASE_URL: postgresql://test:test@localhost:5432/orylo_test
          REDIS_URL: redis://localhost:6379
          STRIPE_WEBHOOK_SECRET: whsec_test_secret
          BETTER_AUTH_SECRET: test_secret_key

      - name: Generate coverage report
        run: bun run test:coverage
        env:
          DATABASE_URL: postgresql://test:test@localhost:5432/orylo_test
          REDIS_URL: redis://localhost:6379

      - name: Upload coverage to Codecov (optional)
        uses: codecov/codecov-action@v3
        with:
          files: ./coverage/coverage-final.json
          flags: integration
          fail_ci_if_error: false
```

### Error Handling
- **Test DB unavailable**: Fail fast with clear error message
- **Stripe signature validation**: Use test webhook secret
- **Session creation fails**: Skip auth-required tests, report error

### Security Considerations
- Test database isolated from production
- Use test Stripe keys (sk_test_, whsec_test_)
- No real user data in tests

### Testing Standards

**Test File Locations** (already defined above)

**Testing Framework**: Vitest (integration tests)

**Coverage Target**: 
- AC6: ≥60% for `apps/web/app/api/**`
- Measured with Vitest coverage plugin (v8)

**Test Execution**:
```bash
# Run all integration tests
bun run test:integration

# Run with coverage
bun run test:coverage

# Watch mode (development)
bun run test:watch
```

---

## Testing

### Integration Test Suites
- **Webhooks** (AC2): Valid, duplicate, invalid signature
- **Detections API** (AC3): Filters, pagination, multi-tenancy
- **Block Customer** (AC4): Database update, multi-tenancy
- **Trust Score Flow** (AC5): New customer, score updates
- **GDPR Endpoints** (Story 3.5): Deletion, export

### Coverage Report
- Run `bun run test:coverage` to generate HTML report
- Verify ≥60% for `app/api/**` (AC6)
- View report at `coverage/index.html`

### CI/CD
- GitHub Actions runs on every PR (AC7)
- Tests run against Postgres + Redis services
- Coverage report uploaded to Codecov (optional)

---

## Change Log

| Date | Version | Description | Author |
|------|---------|-------------|--------|
| 2026-01-13 | 1.0 | Story created | Sarah (PO) |
| 2026-01-24 | 1.1 | Comprehensive test examples, CI/CD setup, coverage configuration | Sarah (PO) |

---

## Dev Agent Record

### Agent Model Used
Claude Sonnet 4.5 (via Cursor)

### Implementation Summary
Implemented comprehensive integration testing infrastructure for API routes and webhooks. Created integration test configuration (vitest.config.integration.ts), test database setup with cleanup, helper utilities for Stripe webhooks and auth mocking, and integration tests for webhooks (valid/duplicate/invalid signature), detections API (filters, pagination, multi-tenancy), block customer endpoint, trust score updates, and data retention cron job. Added GitHub Actions workflow for CI/CD integration with PostgreSQL and Redis services. All tests use direct route handler imports with mocked dependencies for reliable, fast execution.

### Completion Notes List
- Created vitest.config.integration.ts with 60% coverage thresholds
- Created test/setup-integration.ts for database setup and cleanup
- Created test helpers: stripe-fixtures.ts (webhook event generation, signature generation), auth-helpers.ts (session mocking)
- Integration tests for webhooks: valid signature processing, duplicate event idempotency, invalid signature rejection
- Integration tests for detections API: filters, pagination, multi-tenancy enforcement, date range filtering
- Integration tests for block customer: trust score update, multi-tenancy enforcement, authentication checks
- Integration tests for trust score updates: successful payment, chargeback, blocked transaction, new customer creation
- Integration tests for data retention cron: 90-day deletion, CRON_SECRET authentication
- GitHub Actions workflow with PostgreSQL and Redis services
- Added test:integration scripts to package.json

### File List
**Created:**
- `apps/web/vitest.config.integration.ts` - Integration test configuration
- `apps/web/test/setup-integration.ts` - Test database setup and cleanup
- `apps/web/test/helpers/stripe-fixtures.ts` - Stripe webhook test fixtures
- `apps/web/test/helpers/auth-helpers.ts` - Auth mocking helpers
- `apps/web/app/api/webhooks/stripe/__tests__/route.integration.test.ts` - Webhook integration tests
- `apps/web/app/api/detections/__tests__/route.integration.test.ts` - Detections API integration tests (replaced placeholder)
- `apps/web/app/api/customers/[id]/__tests__/block.integration.test.ts` - Block customer integration tests
- `apps/web/app/api/cron/data-retention/__tests__/route.integration.test.ts` - Data retention cron tests
- `apps/web/app/api/__tests__/trust-score-update.integration.test.ts` - Trust score update flow tests
- `.github/workflows/test-integration.yml` - CI/CD workflow for integration tests

**Modified:**
- `apps/web/package.json` - Added test:integration scripts

### Debug Log References
- Test execution: Run `bun run test:integration:run` in apps/web directory
- Coverage reports: Generated in `apps/web/coverage/` directory
- CI/CD: Integration tests run automatically on PR and push to main
- Test database: Uses TEST_DATABASE_URL or falls back to DATABASE_URL
- Test isolation: Each test cleans up data in afterEach hook

---

## QA Results

(To be filled by QA Agent after implementation review)
